# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z4ENDIFbsoJBLHzLlratmL55rUyzdI4s
"""

import streamlit as st
import pandas as pd
import altair as alt
from supabase import create_client
from postgrest.exceptions import APIError

# --- KONFIGURACJA Z TWOIMI DANYMI ---
st.set_page_config(page_title="Magazyn Pro", page_icon="üè≠", layout="wide")

# Twoje dane wpisane na sztywno:
URL = "https://dwsforgsvmpkekgaersp.supabase.co"
KEY = "sb_publishable_wZntU1PpmjLd9IHdpv4L5w_DWdmmPJh"

@st.cache_resource
def init_connection():
    try:
        return create_client(URL, KEY)
    except Exception as e:
        st.error(f"B≈ÇƒÖd po≈ÇƒÖczenia z Supabase: {e}")
        st.stop()

supabase = init_connection()

# --- FUNKCJE BAZY DANYCH ---

def pobierz_dane_df():
    """Pobiera dane i od razu zamienia je na Pandas DataFrame (do wykres√≥w)."""
    try:
        response = supabase.table('magazyn').select("*").execute()
        df = pd.DataFrame(response.data)

        if not df.empty:
            # Upewniamy siƒô, ≈ºe kolumny liczbowe sƒÖ liczbami
            df['ilosc'] = pd.to_numeric(df['ilosc'], errors='coerce').fillna(0)
            df['cena'] = pd.to_numeric(df['cena'], errors='coerce').fillna(0.0)
            df['min_stan'] = pd.to_numeric(df['min_stan'], errors='coerce').fillna(0)

            # Obliczamy warto≈õƒá ka≈ºdego towaru (ilo≈õƒá * cena)
            df['wartosc_calkowita'] = df['ilosc'] * df['cena']
        return df
    except APIError as e:
        st.error(f"B≈ÇƒÖd bazy: {e.message}")
        return pd.DataFrame()

def dodaj_produkt(nazwa, kategoria, opis, ilosc, cena, min_stan):
    dane = {
        "nazwa": str(nazwa),
        "kategoria": str(kategoria),
        "opis": str(opis),
        "ilosc": int(ilosc),        # Tu zak≈Çadamy liczby ca≈Çkowite dla sztuk
        "cena": float(cena),        # Tu float dla ceny (np. 2.50)
        "min_stan": int(min_stan)
    }
    try:
        supabase.table('magazyn').insert(dane).execute()
        return True, "Dodano pomy≈õlnie."
    except APIError as e:
        return False, f"B≈ÇƒÖd Supabase: {e.message} (Kod: {e.code})"

def aktualizuj_stan(id_produktu, zmiana):
    try:
        # Pobieramy obecny stan
        res = supabase.table('magazyn').select("ilosc").eq("id", id_produktu).single().execute()
        if not res.data: return False, "Brak towaru."

        obecna_ilosc = int(res.data.get('ilosc', 0))
        nowa_ilosc = obecna_ilosc + int(zmiana)

        if nowa_ilosc < 0: return False, "Brak wystarczajƒÖcej ilo≈õci towaru!"

        supabase.table('magazyn').update({"ilosc": nowa_ilosc}).eq("id", id_produktu).execute()
        return True, f"Nowy stan: {nowa_ilosc}"
    except APIError as e:
        return False, str(e)

# --- INTERFEJS APLIKACJI ---

st.title("üè≠ Centrum ZarzƒÖdzania Magazynem")

# Menu g≈Ç√≥wne (Zak≈Çadki)
tab_dash, tab_lista, tab_operacje, tab_nowy = st.tabs([
    "üìà Dashboard i Wykresy",
    "üìã Lista i Alarmy",
    "üîÑ Dostawa / Wydanie",
    "‚ûï Dodaj Produkt"
])

# Pobieramy dane raz na poczƒÖtku
df = pobierz_dane_df()

# --- ZAK≈ÅADKA 1: DASHBOARD (WYKRESY) ---
with tab_dash:
    if not df.empty:
        # --- KPI ---
        total_sztuk = df['ilosc'].sum()
        total_wartosc = df['wartosc_calkowita'].sum()
        # Liczymy ile produkt√≥w ma stan poni≈ºej minimum
        alarmy_count = df[df['ilosc'] <= df['min_stan']].shape[0]

        k1, k2, k3 = st.columns(3)
        k1.metric("üì¶ ≈ÅƒÖcznie sztuk", f"{int(total_sztuk)}")
        k2.metric("üí∞ Warto≈õƒá magazynu", f"{total_wartosc:.2f} PLN")
        k3.metric("‚ö†Ô∏è Alarmy (Dom√≥wiƒá)", f"{alarmy_count}", delta_color="inverse")

        st.divider()

        # --- WYKRESY ---
        c1, c2 = st.columns(2)

        with c1:
            st.subheader("üí∞ Warto≈õƒá wg Kategorii")
            if 'kategoria' in df.columns:
                df_kat = df.groupby('kategoria')['wartosc_calkowita'].sum().reset_index()

                # Wykres ko≈Çowy
                base = alt.Chart(df_kat).encode(theta=alt.Theta("wartosc_calkowita", stack=True))
                pie = base.mark_arc(outerRadius=120).encode(
                    color="kategoria",
                    order=alt.Order("wartosc_calkowita", sort="descending"),
                    tooltip=["kategoria", "wartosc_calkowita"]
                )
                text = base.mark_text(radius=140).encode(
                    text=alt.Text("wartosc_calkowita", format=".1f"),
                    order=alt.Order("wartosc_calkowita", sort="descending")
                )
                st.altair_chart(pie + text, use_container_width=True)

        with c2:
            st.subheader("üìä Ilo≈õƒá sztuk produkt√≥w")
            st.bar_chart(df, x="nazwa", y="ilosc", color="kategoria")

    else:
        st.info("Baza jest pusta lub wystƒÖpi≈Ç b≈ÇƒÖd pobierania danych. Dodaj produkt w ostatniej zak≈Çadce.")

# --- ZAK≈ÅADKA 2: LISTA I ALARMY ---
with tab_lista:
    st.header("Szczeg√≥≈Çowy stan magazynowy")

    if not df.empty:
        # Funkcja do kolorowania wierszy
        def highlight_low_stock(row):
            try:
                if row['ilosc'] <= row['min_stan']:
                    return ['background-color: #ffcccc'] * len(row)
            except:
                pass
            return [''] * len(row)

        # Wybieramy i porzƒÖdkujemy kolumny
        cols_to_show = ['id', 'nazwa', 'kategoria', 'ilosc', 'min_stan', 'cena', 'wartosc_calkowita', 'opis']
        # Wy≈õwietlamy tylko te kolumny, kt√≥re faktycznie istniejƒÖ w DataFrame
        dostepne_kolumny = [c for c in cols_to_show if c in df.columns]
        view_df = df[dostepne_kolumny]

        st.dataframe(
            view_df.style.apply(highlight_low_stock, axis=1).format({"cena": "{:.2f} z≈Ç", "wartosc_calkowita": "{:.2f} z≈Ç"}),
            use_container_width=True,
            hide_index=True
        )

        if st.checkbox("Poka≈º tylko produkty do zam√≥wienia (Alarm)"):
            st.dataframe(df[df['ilosc'] <= df['min_stan']])
    else:
        st.warning("Brak danych.")

# --- ZAK≈ÅADKA 3: OPERACJE ---
with tab_operacje:
    st.header("Szybkie przyjƒôcia i wydania")
    if not df.empty:
        col_list, col_action = st.columns([2, 1])

        with col_list:
            # Lista rozwijana
            opcje = {f"{row['nazwa']} (Stan: {row['ilosc']})": row['id'] for i, row in df.iterrows()}
            wybrany_klucz = st.selectbox("Wybierz produkt:", list(opcje.keys()))
            wybrane_id = opcje[wybrany_klucz]

        with col_action:
            ilosc_op = st.number_input("Liczba sztuk", min_value=1, value=1)

            c_plus, c_minus = st.columns(2)
            if c_plus.button("‚ûï Przyjmij", use_container_width=True):
                ok, msg = aktualizuj_stan(wybrane_id, ilosc_op)
                if ok: st.success(msg); st.rerun()
                else: st.error(msg)

            if c_minus.button("‚ûñ Wydaj", use_container_width=True):
                ok, msg = aktualizuj_stan(wybrane_id, -ilosc_op)
                if ok: st.success(msg); st.rerun()
                else: st.error(msg)
    else:
        st.warning("Najpierw dodaj produkty.")

# --- ZAK≈ÅADKA 4: NOWY PRODUKT ---
with tab_nowy:
    st.header("Rejestracja nowego asortymentu")
    with st.form("add_prod"):
        c1, c2 = st.columns(2)
        with c1:
            n_nazwa = st.text_input("Nazwa")
            n_kat = st.selectbox("Kategoria", ["Elektronika", "Spo≈ºywcze", "Budowlane", "Chemia", "Biurowe", "Inne"])
            n_opis = st.text_area("Opis")
        with c2:
            n_ilosc = st.number_input("Ilo≈õƒá startowa", min_value=0, step=1)
            n_cena = st.number_input("Cena zakupu (PLN)", min_value=0.0, step=0.01, format="%.2f")
            n_min = st.number_input("Min. stan (Alarm)", value=5)

        if st.form_submit_button("Zapisz w bazie"):
            if n_nazwa:
                # Wywo≈Çanie funkcji dodawania
                ok, msg = dodaj_produkt(n_nazwa, n_kat, n_opis, n_ilosc, n_cena, n_min)
                if ok:
                    st.success(msg)
                    st.rerun()
                else:
                    st.error(msg)
            else:
                st.warning("Nazwa jest wymagana.")